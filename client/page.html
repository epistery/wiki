<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wiki</title>
  <link rel="stylesheet" href="/style/static.css">
  <link rel="stylesheet" href="/agent/epistery/wiki/client/wiki.css">
  <script src="/script/common.js"></script>
  <style>
    .wiki-main {
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
    }

    .wiki-header-bar {
      flex-shrink: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacer) var(--spacer2);
      border-bottom: 1px solid var(--page-border);
      background: var(--bg-color);
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
    }

    .wiki-body-tray {
      overflow-y:auto;
      padding: var(--spacer2);
    }

    .wiki-body {
      max-width: 800px;
      margin: 0 auto;
    }
    .wiki-header-actions {
      display: flex;
      gap: var(--spacerhalf);
      align-items: center;
    }

    .btn {
      padding: var(--spacerhalf) var(--spacer);
      border: 1px solid var(--page-border);
      border-radius: 4px;
      background: var(--bg-color);
      cursor: pointer;
      text-decoration: none;
      color: var(--text-color);
      font-size: 0.875em;
    }

    .btn:hover {
      background: var(--bg-color-d);
    }

    .btn-primary {
      background: var(--rust-mid);
      color: white;
      border-color: var(--rust-mid);
    }

    .btn-primary:hover {
      background: var(--rust-deep);
    }

    .wiki-meta {
      margin-top: var(--spacer2);
      padding-top: var(--spacer);
      border-top: 1px solid var(--page-border);
      font-size: 0.875em;
      color: var(--text-color-quiet);
    }

    .wiki-breadcrumb {
      font-size: 0.9em;
      color: var(--text-color-quiet);
      display: flex;
      align-items: center;
      gap: var(--spacerhalf);
      flex: 1;
    }

    .wiki-breadcrumb a {
      color: var(--text-color-quiet);
      text-decoration: none;
    }

    .wiki-breadcrumb a:hover {
      color: var(--rust-mid);
      text-decoration: underline;
    }

    .wiki-breadcrumb-sep {
      color: var(--text-color-quiet);
    }
    /* Editor styles */
    .wiki-editor {
      display: none;
    }

    .wiki-editor.active {
      display: block;
    }

    .wiki-viewer.hidden {
      display: none;
    }

    .wiki-editor textarea {
      width: 100%;
      min-height: 500px;
      padding: var(--spacer);
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border: 1px solid var(--page-border);
      border-radius: 4px;
      resize: vertical;
      background: var(--bg-color);
      color: var(--text-color);
    }

    .wiki-editor-toolbar {
      display: flex;
      gap: var(--spacer);
      margin-bottom: var(--spacer);
      align-items: center;
    }

    .wiki-editor-toolbar input,
    .wiki-editor-toolbar select {
      padding: var(--spacerhalf);
      font-size: 1em;
      border: 1px solid var(--page-border);
      border-radius: 4px;
      background: var(--bg-color);
      color: var(--text-color);
    }

    .wiki-editor-toolbar input {
      flex: 1;
    }

    .error {
      background: #ffe6e6;
      color: var(--status-error);
      padding: var(--spacer);
      border-radius: 4px;
      margin-bottom: var(--spacer);
      border: 1px solid var(--status-error);
    }

    .loading {
      text-align: center;
      padding: var(--spacer2);
      color: var(--text-color-quiet);
    }

    /* Sidebar index */
    .wiki-index ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .wiki-index li {
      margin: 0;
      padding: 0;
    }

    .wiki-index-item {
      display: flex;
      align-items: center;
      padding: var(--spacerthird) 0;
    }

    .wiki-index-toggle {
      width: 20px;
      height: 20px;
      border: none;
      background: none;
      cursor: pointer;
      padding: 0;
      margin-right: var(--spacerthird);
      font-size: 0.75em;
      color: var(--text-color-quiet);
      flex-shrink: 0;
    }

    .wiki-index-toggle:hover {
      color: var(--rust-mid);
    }

    .wiki-index-toggle.empty {
      visibility: hidden;
    }

    .wiki-index-link {
      color: var(--text-color);
      text-decoration: none;
      flex: 1;
      padding: var(--spacerthird) var(--spacerhalf);
      border-radius: 3px;
      font-size: 0.9em;
    }

    .wiki-index-link:hover {
      background: var(--bg-color-d);
      color: var(--rust-mid);
    }

    .wiki-index-link.active {
      background: var(--rust-light);
      color: white;
      font-weight: 500;
    }

    .wiki-index-children {
      margin-left: 1em;
      padding-left: 0.5em;
      border-left: 2px solid #ddd;
      display: none;
    }

    .wiki-index-children.expanded {
      display: block;
    }

    /* Sidebar access box */
    #sidebar-access-box {
      background: var(--bg-color);
      border: 1px solid var(--page-border);
      border-radius: 8px;
      padding: var(--spacer2);
      margin-bottom: var(--spacer2);
    }

    #sidebar-access-box h4 {
      margin: 0 0 var(--spacerhalf) 0;
      font-size: 14px;
      color: var(--text-color);
    }

    #sidebar-access-box p {
      margin: 0 0 var(--spacer) 0;
      font-size: 13px;
      color: var(--text-color-quiet);
      line-height: 1.4;
    }

    #sidebar-access-box button {
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
      background: var(--action-color);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    #sidebar-access-box button:hover {
      background: var(--action-color-hilite);
    }
    #modified-tag {
      color: inherit;
      text-decoration: none;
    }
  </style>
</head>
<body>
<header>
  <nav>
    <a href="/?home" class="logo">
      <img alt="logo" src="/image/epistery-logo-32.svg" class="logo-window">
    </a>
    <div class="nav-menu" id="nav-menu"></div>
  </nav>
</header>

<main class="console-layout">
  <div class="console-main wiki-main">
      <div class="wiki-header-bar">
        <div id="breadcrumb" class="wiki-breadcrumb"></div>
        <div class="wiki-header-actions">
          <button class="btn btn-primary" id="edit-btn-header" style="display: none;">Edit</button>
          <a id="admin-btn-header" href="/agent/epistery/wiki/admin" class="btn" style="display: none;">Admin</a>
        </div>
      </div>

      <div class="wiki-body-tray">
        <div class="wiki-body">
          <div id="error" class="error" style="display: none;"></div>

          <div id="loading" class="loading">Loading...</div>

          <div id="viewer" class="wiki-viewer" style="display: none;">
            <div class="wiki-content" id="doc-content"></div>
            <div class="wiki-meta" id="doc-meta"></div>
          </div>

          <div id="editor" class="wiki-editor">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacer2);">
              <h2>Editing: <span id="edit-doc-id"></span></h2>
              <div style="display: flex; gap: var(--spacerhalf);">
                <button class="btn" id="cancel-btn">Cancel</button>
                <button class="btn btn-primary" id="save-btn">Save</button>
              </div>
            </div>
            <div class="wiki-editor-toolbar">
              <input type="text" id="edit-title" placeholder="Document title">
              <select id="edit-parent">
                <option value="">(Root level)</option>
              </select>
              <select id="edit-visibility">
                <option value="public">Public</option>
                <option value="private">Private</option>
              </select>
            </div>
            <textarea id="edit-body" placeholder="Enter markdown content..."></textarea>
          </div>
        </div>
      </div>
    </div>

    <div class="console-sidebar">
      <div id="sidebar-access-box"></div>
      <div class="wiki-index">
        <div id="index-tree"></div>
      </div>
    </div>
  </main>

  <script type="module">
    import Witness from '/lib/witness.js'
    import ZebraTime from '/lib/zebratime.js'
    const API_BASE = '/agent/epistery/wiki';

    let currentDoc = null;
    let markupRenderer = null;
    let allDocs = [];
    const witness = await Witness.connect({rootPath:"/"});

    // Initialize MarkUp renderer
    async function initMarkup() {
      if (!markupRenderer) {
        const MarkUp = await import(`${API_BASE}/client/MarkUp.mjs`).then(m => m.default);
        markupRenderer = new MarkUp({ basePath: API_BASE });
        await markupRenderer.init();
      }
      return markupRenderer;
    }

    // Get doc ID from URL path
    function getDocId() {
      const path = window.location.pathname;
      const match = path.match(/\/agent\/epistery\/wiki\/(.+)/);
      return match ? decodeURIComponent(match[1]) : 'Home';
    }

    // Build and render the index tree
    function renderIndexTree() {
      const currentDocId = getDocId();

      // Build parent-child map: map parent ID to list of children
      const childrenMap = new Map();

      allDocs.forEach(doc => {
        const parentId = doc._pid || '';

        // Prevent self-reference: a doc cannot be its own parent
        if (parentId === doc._id) {
          console.warn(`[wiki] Document ${doc._id} has circular _pid reference (points to itself)`);
          return; // Skip this doc - treat as root
        }

        if (!childrenMap.has(parentId)) {
          childrenMap.set(parentId, []);
        }
        childrenMap.get(parentId).push(doc);
      });

      // Get all root documents (those with _pid === '' or no _pid)
      const rootDocs = childrenMap.get('') || [];

      // Render tree recursively with cycle detection
      function renderNode(doc, ancestors = new Set()) {
        // Detect cycles: if this doc is already in our ancestor chain, skip it
        if (ancestors.has(doc._id)) {
          console.warn(`[wiki] Circular reference detected in tree for ${doc._id}`);
          return null;
        }

        const children = childrenMap.get(doc._id) || [];
        const hasChildren = children.length > 0;
        const isActive = doc._id === currentDocId;

        const li = document.createElement('li');

        const itemDiv = document.createElement('div');
        itemDiv.className = 'wiki-index-item';

        // Toggle button
        const toggle = document.createElement('button');
        toggle.className = 'wiki-index-toggle' + (hasChildren ? '' : ' empty');
        toggle.textContent = hasChildren ? '‚ñ∂' : '';
        toggle.setAttribute('aria-label', 'Toggle children');

        // Link
        const link = document.createElement('a');
        link.href = API_BASE + '/' + encodeURIComponent(doc._id);
        link.className = 'wiki-index-link' + (isActive ? ' active' : '');
        link.textContent = doc.title || doc._id;

        itemDiv.appendChild(toggle);
        itemDiv.appendChild(link);
        li.appendChild(itemDiv);

        // Children container
        if (hasChildren) {
          const childrenUl = document.createElement('ul');
          childrenUl.className = 'wiki-index-children';

          // Auto-expand Home and any ancestor of current doc
          if (doc._id === 'Home') {
            childrenUl.classList.add('expanded');
            toggle.textContent = '‚ñº';
          }

          // Create new ancestor set for children
          const childAncestors = new Set(ancestors);
          childAncestors.add(doc._id);

          children
            .sort((a, b) => (a.title || a._id).localeCompare(b.title || b._id))
            .forEach(child => {
              const childNode = renderNode(child, childAncestors);
              if (childNode) {
                childrenUl.appendChild(childNode);
              }
            });

          li.appendChild(childrenUl);

          // Toggle handler
          toggle.addEventListener('click', (e) => {
            e.preventDefault();
            const isExpanded = childrenUl.classList.toggle('expanded');
            toggle.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
          });
        }

        return li;
      }

      const tree = document.createElement('ul');
      rootDocs
        .sort((a, b) => (a.title || a._id).localeCompare(b.title || b._id))
        .forEach(doc => {
          tree.appendChild(renderNode(doc));
        });

      document.getElementById('index-tree').innerHTML = '';
      document.getElementById('index-tree').appendChild(tree);

      // Auto-expand to show current document (in addition to Home)
      expandToDocument(currentDocId);
    }

    // Expand tree to show a specific document
    function expandToDocument(docId) {
      const doc = allDocs.find(d => d._id === docId);
      if (!doc) return;

      // Build path to root with cycle detection
      const path = [docId];
      const visited = new Set([docId]);
      let current = doc;

      while (current._pid && current._pid !== '' && !visited.has(current._pid)) {
        // Prevent self-reference
        if (current._pid === current._id) {
          console.warn(`[wiki] Document ${current._id} has circular _pid reference in expandToDocument`);
          break;
        }

        path.unshift(current._pid);
        visited.add(current._pid);
        current = allDocs.find(d => d._id === current._pid);
        if (!current) break;
      }

      // Expand all parents
      path.forEach(id => {
        const link = document.querySelector(`.wiki-index-link[href="${API_BASE}/${encodeURIComponent(id)}"]`);
        if (link) {
          const item = link.closest('li');
          const childrenUl = item?.querySelector('.wiki-index-children');
          const toggle = item?.querySelector('.wiki-index-toggle');
          if (childrenUl && toggle) {
            childrenUl.classList.add('expanded');
            toggle.textContent = '‚ñº';
          }
        }
      });

      // Scroll active document into view
      const activeLink = document.querySelector('.wiki-index-link.active');
      if (activeLink) {
        activeLink.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    // Load index data
    async function loadIndexData() {
      try {
        const response = await fetch(`${API_BASE}/index`);
        allDocs = await response.json();
        renderIndexTree();
      } catch (error) {
        console.error('[wiki] Failed to load index:', error);
      }
    }

    // Load and display document
    async function loadDocument(docId) {
      document.getElementById('loading').style.display = 'block';
      document.getElementById('viewer').style.display = 'none';
      document.getElementById('editor').classList.remove('active');
      document.getElementById('error').style.display = 'none';

      try {
        const response = await fetch(`${API_BASE}/${encodeURIComponent(docId)}`, {
          headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`Failed to load: ${response.status}`);
        }

        currentDoc = await response.json();

        // New document - server returns template with _new flag and _pid from cookie
        if (currentDoc._new) {
          showEditor();
          return;
        }

        await renderDocument();

      } catch (error) {
        showError(error.message);
      }
    }

    // Build breadcrumb trail
    function renderBreadcrumb() {
      const breadcrumb = document.getElementById('breadcrumb');

      if (!currentDoc) {
        breadcrumb.innerHTML = '';
        return;
      }

      // Build path from current doc to root
      const path = [currentDoc];
      const visited = new Set([currentDoc._id]);

      // Walk up the parent chain using the index data
      let parentId = currentDoc._pid;

      // Prevent self-reference causing infinite loop
      if (parentId === currentDoc._id) {
        console.warn(`[wiki] Document ${currentDoc._id} has circular _pid reference (points to itself)`);
        parentId = ''; // Break the loop
      }

      while (parentId && parentId !== '' && !visited.has(parentId)) {
        const parent = allDocs.find(d => d._id === parentId);
        if (!parent) break;

        path.unshift(parent);
        visited.add(parent._id);
        parentId = parent._pid;

        // Additional safety: prevent parent from pointing to itself
        if (parentId === parent._id) {
          console.warn(`[wiki] Document ${parent._id} has circular _pid reference (points to itself)`);
          break;
        }
      }

      // Always prepend Home if we're not already on Home and Home exists
      const home = allDocs.find(d => d._id === 'Home');
      if (currentDoc._id !== 'Home' && home && path[0]._id !== 'Home') {
        path.unshift(home);
      }

      // Render breadcrumb
      const parts = path.map((doc, i) => {
        if (i === path.length - 1) {
          // Last item (current page) - no link
          return `<span>${escapeHtml(doc.title || doc._id)}</span>`;
        } else {
          return `<a href="${API_BASE}/${encodeURIComponent(doc._id)}">${escapeHtml(doc.title || doc._id)}</a>`;
        }
      });

      breadcrumb.innerHTML = parts.join(' <span class="wiki-breadcrumb-sep">/</span> ');
    }

    // Render document
    async function renderDocument() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('viewer').style.display = 'block';

      // Render breadcrumb
      renderBreadcrumb();

      // Update index tree to highlight current doc
      renderIndexTree();

      // Render markdown with WikiWord processing
      const markup = await initMarkup();
      const html = await markup.render(currentDoc.body || '', { _pid: currentDoc._pid });
      const contentEl = document.getElementById('doc-content');
      contentEl.innerHTML = html;

      // Post-process for Mermaid diagrams
      await markup.renderMermaidDiagrams(contentEl);

      // Meta
      let meta = [];
      if (currentDoc._modified) {
        const date = new Date(currentDoc._modified);
        const day = new Intl.DateTimeFormat('en-US').format(date)
        meta.push(`<a title='last modified, ${date.toLocaleString()} GMT' id='modified-tag' href='https://zebratime.org'>Modified: ${day}, ${ZebraTime(date)}</a>`);
      }
      if (currentDoc.visibility && currentDoc.visibility !== 'public') {
        meta.push('Visibility: ' + currentDoc.visibility);
      }
      document.getElementById('doc-meta').innerHTML = meta.join(' | ');

      document.getElementById('edit-btn-header').style.display = currentDoc.__permissions.edit?'inline-block':'none';
      document.getElementById('admin-btn-header').style.display = currentDoc.__permissions.admin?'inline-block':'none';
      if (!currentDoc.__permissions.edit) {
        showAccessRequestBox();
      } else {
        hideAccessRequestBox();
      }
    }

    // Show editor
    function showEditor() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('viewer').style.display = 'none';
      document.getElementById('viewer').classList.add('hidden');
      document.getElementById('editor').classList.add('active');

      document.getElementById('edit-doc-id').textContent = currentDoc._id;
      document.getElementById('edit-title').value = currentDoc.title || currentDoc._id;
      document.getElementById('edit-body').value = currentDoc.body || '';
      document.getElementById('edit-visibility').value = currentDoc.visibility || 'public';

      // Expand tree to show parent (for new documents)
      if (currentDoc._pid) {
        expandToDocument(currentDoc._pid);
      }

      // Populate parent dropdown
      const parentSelect = document.getElementById('edit-parent');
      const rootOption = document.createElement('option');
      rootOption.value = '';
      rootOption.textContent = '(Root level)';
      rootOption.selected = !currentDoc._pid || currentDoc._pid === '';
      parentSelect.innerHTML = '';
      parentSelect.appendChild(rootOption);

      allDocs
        .filter(d => d._id !== currentDoc._id) // Don't allow setting self as parent
        .sort((a, b) => (a.title || a._id).localeCompare(b.title || b._id))
        .forEach(doc => {
          const option = document.createElement('option');
          option.value = doc._id;
          option.textContent = doc.title || doc._id;
          option.selected = doc._id === currentDoc._pid;
          parentSelect.appendChild(option);
        });

      // Force the select to update its value
      if (currentDoc._pid) {
        parentSelect.value = currentDoc._pid;
      }
    }

    // Hide editor
    function hideEditor() {
      document.getElementById('editor').classList.remove('active');
      document.getElementById('viewer').classList.remove('hidden');
      document.getElementById('viewer').style.display = 'block';
    }

    // Save document
    async function saveDocument() {
      const doc = {
        title: document.getElementById('edit-title').value,
        body: document.getElementById('edit-body').value,
        _pid: document.getElementById('edit-parent').value,
        visibility: document.getElementById('edit-visibility').value
      };

      try {
        const response = await fetch(`${API_BASE}/${encodeURIComponent(currentDoc._id)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(doc)
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({}));

          // Check if it's a permission error
          if (response.status === 403) {
            showAccessRequestBox();
            throw new Error(error.error || 'You need permission to edit this wiki');
          }

          throw new Error(error.error || `Save failed: ${response.status}`);
        }

        currentDoc = await response.json();
        hideEditor();
        await renderDocument();

        // Reload index to reflect new document
        await loadIndexData();

      } catch (error) {
        showError('Save failed: ' + error.message);
      }
    }

    // Show access request box in sidebar
    function showAccessRequestBox() {
      const sidebarBox = document.getElementById('sidebar-access-box');
      if (!sidebarBox) return;

      sidebarBox.innerHTML = `
        <h4>üîê Request Access</h4>
        <p>Request the host to enable this browser for editing.</p>
        <button onclick="showAccessMessageForm()">Request Editor Access</button>
      `;
    }

    // Show message form for access request
    window.showAccessMessageForm = function() {
      const sidebarBox = document.getElementById('sidebar-access-box');
      if (!sidebarBox) return;

      sidebarBox.innerHTML = `
        <h4>üîê Request Access</h4>
        <textarea id="access-message"
          placeholder="Enter a message for the host"
          style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--page-border); border-radius: 4px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 8px;"></textarea>
        <div style="display: flex; gap: 8px;">
          <button onclick="submitWikiAccessRequest()" style="flex: 1;">Send</button>
          <button onclick="cancelWikiAccessRequest()" style="flex: 1; background: var(--bg-color-d); color: var(--text-color);">Cancel</button>
        </div>
      `;

      // Focus the textarea
      setTimeout(() => {
        document.getElementById('access-message')?.focus();
      }, 0);
    };

    // Hide access request box
    function hideAccessRequestBox() {
      const sidebarBox = document.getElementById('sidebar-access-box');
      if (sidebarBox) {
        let addr = witness.wallet.address;
        const shortform = `${addr.slice(0,8)}...${addr.slice(addr.length-6)}`;
        const span = document.createElement('SPAN')
        span.innerHTML = shortform;
        span.title = addr;
        span.style = 'display:block;text-align:center;font-family:monospace;cursor:pointer;margin:-10px 0';
        sidebarBox.innerHTML = ``
        sidebarBox.appendChild(span);
        span.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(addr);
            span.innerHTML = 'copied!';
            setTimeout(()=>{span.innerHTML = shortform},500)
          } catch(error) {
            console.log(error);
          }
        })
      }
    }

    // Cancel request
    window.cancelWikiAccessRequest = function() {
      showAccessRequestBox();
    }

    // Submit wiki access request
    window.submitWikiAccessRequest = async function() {
      try {
        const messageEl = document.getElementById('access-message');
        const message = messageEl?.value || 'Requesting access to edit wiki pages';

        // Get wallet address from localStorage
        const data = localStorage.getItem('epistery');
        if (!data) {
          showError('Please create a wallet first');
          return;
        }

        const parsed = JSON.parse(data);
        let wallet = parsed.wallets?.[0];
        if (wallet && wallet.wallet) {
          wallet = wallet.wallet;
        }

        if (!wallet || !wallet.address) {
          showError('No wallet address found');
          return;
        }

        const address = wallet.rivetAddress || wallet.address;
        const listName = 'epistery::editor';

        const response = await fetch('/agent/epistery/white-list/request-access', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            address,
            listName,
            agentName: 'wiki',
            message,
            name: ''
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Request failed');
        }

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'Request failed');
        }

        // Show success message
        const sidebarBox = document.getElementById('sidebar-access-box');
        if (sidebarBox) {
          sidebarBox.innerHTML = `
            <h4>‚úì Request Submitted</h4>
            <p>Your access request has been sent to the administrators.</p>
          `;
        }

      } catch (error) {
        showError('Failed to request access: ' + error.message);
      }
    };

    // Show error
    function showError(message) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').textContent = message;
      document.getElementById('error').style.display = 'block';
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Event listeners
    document.getElementById('edit-btn-header').addEventListener('click', showEditor);
    document.getElementById('cancel-btn').addEventListener('click', () => {
      if (currentDoc._new) {
        window.location.href = API_BASE + '/Home';
      } else {
        hideEditor();
      }
    });
    document.getElementById('save-btn').addEventListener('click', saveDocument);

    // Initial load
    (async () => {
      await loadIndexData();
      await loadDocument(getDocId());
    })();
  </script>
</body>
</html>
